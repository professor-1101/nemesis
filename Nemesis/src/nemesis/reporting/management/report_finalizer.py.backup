"""Finalization management for reporting."""
import time
import traceback
from datetime import datetime

import requests
from rich.console import Console

from nemesis.infrastructure.logging import Logger


class ReportFinalizer:
    """Finalizes and completes reporting activities."""

    def __init__(self, reporter_manager, execution_manager):
        """Initialize report finalizer."""
        self.logger = Logger.get_instance({})
        self.reporter_manager = reporter_manager
        self.execution_manager = execution_manager

    def finalize(self) -> None:
        """Finalize all reporting."""
        console = Console()
        
        self.logger.info("ReportFinalizer.finalize() called")
        Logger.get_instance({}).info("[DEBUG] ReportFinalizer.finalize() called")

        # Print step message in CLI style (independent of CLI module)
        console.print("[dark_orange]→[/dark_orange] Finalizing reports...")

        # Finalize local reporter - ONLY if enabled
        is_local = self.reporter_manager.is_local_enabled()
        self.logger.info(f"Local reporting enabled: {is_local}")
        Logger.get_instance({}).info(f"[DEBUG] Local reporting enabled: {is_local}")
        
        if is_local:
            try:
                # Print HTML generation message in CLI style
                console.print("[dark_orange]→[/dark_orange] Generating HTML report...")

                local_reporter = self.reporter_manager.get_local_reporter()
                self.logger.info(f"Local reporter object: {local_reporter is not None}")
                Logger.get_instance({}).info(f"[DEBUG] Local reporter object: {local_reporter is not None}")
                
                if local_reporter:
                    self.logger.info(f"Calling generate_report() with {len(local_reporter.execution_data.scenarios)} scenarios")
                    Logger.get_instance({}).info(f"[DEBUG] Calling generate_report() with {len(local_reporter.execution_data.scenarios)} scenarios")
                    local_reporter.generate_report()
                    # Clean console output is handled by LocalReporter._print_report_success()
                else:
                    self.logger.warning("Local reporter is None, cannot generate report")
                    Logger.get_instance({}).info("[DEBUG] Local reporter is None, cannot generate report")
            except (AttributeError, RuntimeError, OSError, IOError) as e:
                # Local report generation errors
                self.logger.error(f"Failed to generate local report: {e}", traceback=traceback.format_exc(), module=__name__, class_name="ReportFinalizer", method="finalize")
            except Exception as e:  # pylint: disable=broad-exception-caught
                # Catch-all for unexpected errors from local reporter
                # NOTE: Local reporter may raise various exceptions we cannot predict
                self.logger.error(f"Failed to generate local report: {e}", traceback=traceback.format_exc(), module=__name__, class_name="ReportFinalizer", method="finalize")
        else:
            self.logger.info("Local reporting disabled, skipping HTML report generation")

        # Finalize ReportPortal
        if self.reporter_manager.is_rp_enabled():
            try:
                rp_client = self.reporter_manager.get_rp_client()
                if rp_client:
                    # Get launch_id from rp_client (includes _finished_launch_id if launch is finished)
                    launch_id = rp_client.launch_id
                    if not launch_id:
                        # Try to get from EnvironmentCoordinator (for cross-process access)
                        try:
                            from nemesis.infrastructure.environment.hooks import _get_env_manager  # pylint: disable=import-outside-toplevel
                            env_manager = _get_env_manager()
                            if env_manager and hasattr(env_manager, 'rp_launch_id') and env_manager.rp_launch_id:
                                launch_id = env_manager.rp_launch_id
                                self.logger.info(f"Retrieved launch_id from EnvironmentCoordinator: {launch_id}")
                        except (AttributeError, ImportError) as get_error:
                            # Non-critical: failed to get launch_id from EnvironmentCoordinator
                            self.logger.debug(f"Could not get launch_id from EnvironmentCoordinator: {get_error}", module=__name__, class_name="ReportFinalizer", method="finalize")
                        except Exception as get_error:  # pylint: disable=broad-exception-caught
                            # Catch-all for unexpected errors from EnvironmentCoordinator access
                            # NOTE: EnvironmentCoordinator import or access may raise various exceptions
                            self.logger.debug(f"Could not get launch_id from EnvironmentCoordinator: {get_error}", module=__name__, class_name="ReportFinalizer", method="finalize")
                    
                    # If still no launch_id, try to get from _finished_launch_id (if launch was finished earlier)
                    if not launch_id and hasattr(rp_client, '_finished_launch_id') and rp_client._finished_launch_id:
                        launch_id = rp_client._finished_launch_id
                        self.logger.info(f"Retrieved launch_id from _finished_launch_id: {launch_id}")

                    if launch_id:
                        launch_url = rp_client.get_launch_url()
                        if launch_url:
                            self.logger.info(f"[RP DEBUG] ReportPortal launch URL: {launch_url}")

                        # CRITICAL: Terminate FIRST to ensure all pending logs/attachments are flushed
                        self.logger.info(f"[RP DEBUG] Checking terminate conditions BEFORE finish...")
                        if hasattr(rp_client, 'rp_client_base') and rp_client.rp_client_base and hasattr(rp_client.rp_client_base, 'client'):
                            try:
                                self.logger.info("Terminating ReportPortal client BEFORE finish_launch...")
                                rp_client.rp_client_base.client.terminate()
                                self.logger.info("ReportPortal client terminated successfully BEFORE finish")
                                time.sleep(0.5)
                            except Exception as terminate_error:
                                self.logger.warning(f"Terminate before finish failed: {terminate_error}")
                        else:
                            self.logger.warning("Cannot terminate client - missing client object")

                        # Always try to finish launch (even if is_healthy() returns False)
                        # is_healthy() checks if launch_id is not None, but launch_id may be cleared after finish
                        # We have the launch_id from _finished_launch_id or launch_id property, so we can finish it
                        self.logger.info(f"[RP DEBUG] Finishing ReportPortal launch: {launch_id}")
                        self.logger.info(f"[RP DEBUG] rp_client.launch_id: {rp_client.launch_id}")
                        self.logger.info(f"[RP DEBUG] rp_client._finished_launch_id: {getattr(rp_client, '_finished_launch_id', 'N/A')}")
                        self.logger.info(f"[RP DEBUG] rp_client.is_healthy(): {rp_client.is_healthy()}")
                        rp_client.finish_launch("FINISHED", launch_id=launch_id)
                        self.logger.info(f"[RP DEBUG] After finish_launch - rp_client.launch_id: {rp_client.launch_id}")

                        # Give time for finish_launch request to be processed
                        time.sleep(0.5)

                        # Make a direct API call as final fallback to ensure launch is finished
                        # This ensures the finish request is sent even if async queue doesn't flush properly
                        self._finish_launch_direct_api(rp_client.rp_client_base, launch_id)
                    else:
                        self.logger.warning("No launch_id available to finish ReportPortal launch")

                    self.logger.info("ReportPortal finalized")
            except (AttributeError, RuntimeError) as e:
                # ReportPortal finalization errors
                self.logger.error(f"ReportPortal finalization failed: {e}", traceback=traceback.format_exc(), module=__name__, class_name="ReportFinalizer", method="finalize")
            except Exception as e:  # pylint: disable=broad-exception-caught
                # Catch-all for unexpected errors from ReportPortal finalization
                # NOTE: ReportPortal SDK may raise various exceptions we cannot predict
                self.logger.error(f"ReportPortal finalization failed: {e}", traceback=traceback.format_exc(), module=__name__, class_name="ReportFinalizer", method="finalize")

        if self.execution_manager:
            self.logger.info(f"Reports saved to: {self.execution_manager.get_execution_path()}")
        else:
            self.logger.info("Reports finalized (no execution manager)")

    def _finish_launch_direct_api(self, rp_client_base, launch_id: str) -> None:
        """
        Make a direct API call to finish launch as a final fallback.
        This ensures the request is sent even if RPClient async queue fails.

        Args:
            rp_client_base: RPClientBase instance
            launch_id: Launch ID to finish
        """
        try:
            # Prepare API endpoint
            endpoint = rp_client_base.endpoint.rstrip("/")
            if not endpoint.endswith("/api/v1"):
                if endpoint.endswith("/api"):
                    endpoint = endpoint[:-4]
                endpoint = f"{endpoint}/api/v1"

            url = f"{endpoint}/{rp_client_base.project}/launch/{launch_id}/finish"

            # Prepare request data - ReportPortal API for finish launch only needs endTime
            # Status is determined automatically based on test results
            end_time = str(int(datetime.now().timestamp() * 1000))
            data = {
                "endTime": end_time
            }

            # Prepare headers - ReportPortal uses Bearer token
            headers = {
                "Authorization": f"Bearer {rp_client_base.api_key}",
                "Content-Type": "application/json"
            }

            # Make the API call
            self.logger.info(f"Making direct API call to finish launch (final fallback): {launch_id}")
            response = requests.put(
                url,
                json=data,
                headers=headers,
                verify=rp_client_base.verify_ssl,
                timeout=10
            )

            if response.status_code in (200, 204):
                self.logger.info(f"Direct API finish_launch succeeded for launch: {launch_id} (status: {response.status_code})")
            elif response.status_code == 400:
                # 400 might mean launch is already finished or invalid request
                # This is not necessarily an error - launch might already be finished
                self.logger.info(f"Direct API finish_launch returned 400 (launch may already be finished): {response.text[:200]}")
            else:
                self.logger.warning(f"Direct API finish_launch returned status {response.status_code}: {response.text[:200]}")

        except (requests.RequestException, OSError, IOError, ValueError) as e:
            # Network or request errors - don't raise, this is a fallback method
            self.logger.warning(f"Direct API finish_launch failed (non-critical): {e}", traceback=traceback.format_exc(), module=__name__, class_name="ReportFinalizer", method="_finish_launch_direct_api")
        except Exception as e:  # pylint: disable=broad-exception-caught
            # Catch-all for unexpected errors from direct API call
            # NOTE: This is a fallback method, so we don't raise
            # Direct API call may raise various exceptions we cannot predict
            self.logger.warning(f"Direct API finish_launch failed (non-critical): {e}", traceback=traceback.format_exc(), module=__name__, class_name="ReportFinalizer", method="_finish_launch_direct_api")

    def is_healthy(self) -> bool:
        """Check if at least one reporter is active."""
        local_ok = self.reporter_manager.is_local_enabled()
        rp_ok = self.reporter_manager.is_rp_enabled()
        return local_ok or rp_ok
